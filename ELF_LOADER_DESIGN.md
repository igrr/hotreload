# ELF Loader Design for Hot Reload

## Executive Summary

This document proposes a design for loading reloadable ELF files into RAM and populating the symbol table. The design is based on analysis of the actual ELF files generated by the build system and the existing `elf_parser` component.

## Key Findings from ELF Analysis

### 1. ELF File Structure

The stripped reloadable ELF (`reloadable_stripped.so`) contains:

**Loadable Sections:**
- `.text` - Code section (AX flags: Allocate + Execute)
- `.rodata` - Read-only data (A flag: Allocate, MS flags: Merge + Strings)
- `.data` - Initialized writable data (WA flags: Write + Allocate)
- `.bss` - Uninitialized writable data (WA flags, NOBITS type)
- `.got` - Global Offset Table (WA flags)

**Example from complex reloadable.c:**
```
Section       VMA      Size   Type
.text         0x026c   0x112  PROGBITS (code)
.rodata       0x0380   0x08a  PROGBITS (strings, constants)
.data.rel.ro  0x142c   0x010  PROGBITS (initialized data with relocations)
.got          0x14dc   0x004  PROGBITS (GOT)
.data         0x14e0   0x000  PROGBITS (initialized data)
.bss          0x14e0   0x02c  NOBITS (uninitialized: data_array + counters)
```

**Non-loadable Sections (already stripped):**
- Debug sections (`.debug_*`)
- Symbol tables (`.symtab`, `.strtab`)
- Architecture-specific (`.xtensa.info`, `.xt.lit`, `.xt.prop` for Xtensa)
- Dynamic linking metadata (`.dynamic`, `.got.loc`)

### 2. Relocation Types

The ELF files use **RELA** relocations (with explicit addend), not REL. The key relocation types are:

**a) R_XTENSA_RELATIVE (Type 5)**
- Used for position-independent code references
- Formula: `*location = load_base + addend`
- Found in `.rela.dyn`

**b) R_XTENSA_JMP_SLOT (Type 4)**
- Used for PLT/GOT entries for external function calls
- These reference functions in main app (printf, esp_get_idf_version)
- Symbol values are already resolved to fixed addresses in main binary
- Formula: `*location = symbol_value`
- Found in `.rela.plt`

**c) R_XTENSA_32 (Type 1)**
- 32-bit absolute references to sections
- Formula: `*location = symbol_value + addend`
- Most common in `.rela.text` for references to .rodata, .data, .bss

**d) R_XTENSA_PLT (Type 6)**
- PLT references for function calls
- Similar to JMP_SLOT but used in code
- Formula: `*location = symbol_value`

**e) R_XTENSA_SLOT0_OP (Type 20)**
- Xtensa-specific instruction slot relocations
- Used for internal code references within .text
- Requires special handling for Xtensa instruction encoding

**f) R_XTENSA_RTLD (Type 2)**
- Runtime loader relocation markers
- Can likely be ignored for our use case

### 3. Critical Insight: No Dynamic Relocations Needed

Unlike typical dynamic libraries, our reloadable ELF files:
- ✅ Have external symbols (printf, etc.) **pre-resolved** to fixed addresses in the main binary
- ✅ Use only **section-relative** relocations internally
- ❌ Do NOT have unresolved symbol dependencies
- ❌ Do NOT need runtime symbol resolution against external libraries

This is achieved by the custom linker script (`reloadable.ld`) that links against the main binary's symbols at build time.

## Proposed Loading Strategy

### Phase 1: Memory Layout Calculation

**Goal:** Determine how much RAM is needed and where each section goes.

```
1. Parse ELF header to get section headers
2. For each ALLOC section (SHF_ALLOC flag set):
   a. Record section VMA, size, alignment
   b. Determine if it's NOBITS (.bss) or PROGBITS
3. Calculate total memory needed:
   - Find lowest VMA and highest VMA + size
   - Account for alignment requirements
4. Allocate a single contiguous RAM block
```

**Alternative Approaches:**

**Option A: Preserve Original VMA Layout**
- Allocate RAM starting at address X
- Load each section at: `X + (section_vma - base_vma)`
- **Pros:** Simple, preserves relative offsets between sections
- **Cons:** May waste RAM if sections have gaps

**Option B: Compact Layout**
- Pack sections tightly in RAM, respecting alignment
- Track mapping: original VMA → actual RAM address
- **Pros:** Minimal RAM usage
- **Cons:** More complex relocation calculations

**Recommendation:** Start with **Option A** for simplicity. The ELF files are small (< 10KB), so wasted space is negligible.

### Phase 2: Section Loading

**Goal:** Copy section data from flash to RAM.

```
1. For each PROGBITS section with ALLOC flag:
   a. Calculate target RAM address based on chosen layout
   b. Read section data from flash (at section file offset)
   c. Copy to RAM
2. For each NOBITS section (.bss):
   a. Calculate target RAM address
   b. Zero-fill the memory
```

**Implementation Detail:**
Use the existing `elf_parser_read_cb_t` callback mechanism to read section data from flash.

### Phase 3: Relocation Processing

**Goal:** Fix up all relocations so code and data references point to correct RAM addresses.

```
For each relocation section (.rela.text, .rela.dyn, .rela.plt, .rela.data.rel.ro):
    For each relocation entry:
        1. Calculate relocation target address in RAM
        2. Determine relocation type
        3. Apply relocation formula
        4. Write patched value to RAM
```

**Relocation Formulas:**

```c
// Base address where ELF is loaded in RAM
uintptr_t load_base = ...;

// For each relocation:
uintptr_t *location = (uintptr_t *)(load_base + rel->r_offset);
uint32_t sym_value = ...; // from symbol table or section
int32_t addend = rel->r_addend;

switch (ELF32_R_TYPE(rel->r_info)) {
    case R_XTENSA_RELATIVE:
        *location = load_base + addend;
        break;

    case R_XTENSA_32:
        // sym_value is usually section base + offset
        *location = sym_value + addend;
        break;

    case R_XTENSA_JMP_SLOT:
    case R_XTENSA_PLT:
        // sym_value already points to main app function
        *location = sym_value;
        break;

    case R_XTENSA_SLOT0_OP:
        // Xtensa instruction encoding - see TRM
        // This patches specific instruction fields
        apply_xtensa_slot0_relocation(location, sym_value + addend);
        break;

    case R_XTENSA_RTLD:
    case R_XTENSA_NONE:
        // Skip
        break;

    default:
        return ESP_ERR_NOT_SUPPORTED;
}
```

**Symbol Resolution:**
- For section symbols: `sym_value = load_base + section_vma`
- For external symbols (printf, etc.): `sym_value` is already in the symbol table as a fixed address
- For local symbols: Calculate based on section + offset

### Phase 4: Symbol Table Population

**Goal:** Update the symbol table in the main app to point to exported functions.

**Current Mechanism:**
- Main app has `hotreload_symbol_table[]` (array of function pointers)
- Stub functions jump through this table
- Need to populate table with addresses of `reloadable_init`, `reloadable_hello`, etc.

**Proposed Approach:**

```
1. Parse .symtab section to find exported functions
2. For each symbol:
   a. Check if it's a function (STT_FUNC) with global binding (STB_GLOBAL)
   b. Check if symbol name matches expected reloadable functions
   c. Calculate actual RAM address: load_base + sym->st_value
   d. Store in symbol table
```

**Refactored API:**

```c
typedef struct {
    const char *name;          // Function name
    void **table_entry;        // Pointer to symbol table slot
} hotreload_symbol_t;

// Register which symbols to resolve
esp_err_t hotreload_register_symbols(const hotreload_symbol_t *symbols, size_t count);

// Load ELF and populate registered symbols
esp_err_t hotreload_load_elf(const void *elf_data, size_t elf_size);
```

This is cleaner than the current "pull" approach where `hotreload_get_symbol_address` is called repeatedly.

## Memory Management

### RAM Requirements

**Estimated sizes for typical reloadable code:**
- Simple example (current): ~2KB
- Complex example (with arrays/structs): ~4-6KB
- Realistic use case: ~10-20KB

**Allocation Strategy:**

**Option 1: Static Allocation**
```c
static uint8_t reloadable_ram[20*1024] __attribute__((aligned(16)));
```
- **Pros:** Simple, no heap fragmentation
- **Cons:** Wastes RAM if not reloading, fixed size limit

**Option 2: Dynamic Allocation**
```c
void *reloadable_ram = heap_caps_malloc(calculated_size, MALLOC_CAP_EXEC);
```
- **Pros:** Only uses RAM when needed, size flexible
- **Cons:** Requires EXEC heap capability, fragmentation risk

**Option 3: Hybrid**
```c
static uint8_t reloadable_ram_static[10*1024];
void *reloadable_ram_dynamic = NULL;

if (needed_size <= sizeof(reloadable_ram_static)) {
    use reloadable_ram_static;
} else {
    reloadable_ram_dynamic = heap_caps_malloc(needed_size, MALLOC_CAP_EXEC);
}
```

**Recommendation:** Start with **Option 1** (static) for prototype, move to **Option 3** (hybrid) for production.

### Instruction Cache Coherency

After loading and relocating code, must ensure I-cache sees updated memory:

```c
#include "esp_cache.h"

// After all relocations are applied:
esp_cache_msync(reloadable_ram, total_size, ESP_CACHE_MSYNC_FLAG_DIR_C2M);
```

This is critical on ESP32 to ensure CPU fetches updated instructions.

## Implementation Plan

### Step 1: Extend elf_parser

Current `elf_parser` only supports `SHT_REL` (without addend). Need to add:

```c
// Add to elf_parser.h
typedef struct elf_relocation_a *elf_relocation_a_handle_t;

void      elf_parser_get_relocations_a_it(const elf_parser_handle_t parser,
                                          elf_iterator_handle_t *it_out);
bool      elf_reloc_a_next(const elf_parser_handle_t parser,
                          elf_iterator_handle_t *it,
                          elf_relocation_a_handle_t *out);
intptr_t  elf_reloc_a_get_addend(elf_relocation_a_handle_t rel);
// ... other accessors similar to elf_reloc_*
```

### Step 2: Implement ELF Loader Module

Create `components/hotreload/elf_loader.c`:

```c
typedef struct {
    void *ram_base;           // Where ELF is loaded in RAM
    size_t ram_size;          // Total RAM allocated
    uintptr_t vma_base;       // Base VMA from ELF
    elf_parser_handle_t parser;
} elf_loader_ctx_t;

esp_err_t elf_loader_init(elf_loader_ctx_t *ctx, const void *elf_data);
esp_err_t elf_loader_allocate(elf_loader_ctx_t *ctx);
esp_err_t elf_loader_load_sections(elf_loader_ctx_t *ctx);
esp_err_t elf_loader_apply_relocations(elf_loader_ctx_t *ctx);
esp_err_t elf_loader_sync_cache(elf_loader_ctx_t *ctx);
void*     elf_loader_get_symbol(elf_loader_ctx_t *ctx, const char *name);
void      elf_loader_cleanup(elf_loader_ctx_t *ctx);
```

### Step 3: Implement Xtensa-Specific Relocations

Create `components/hotreload/arch/xtensa/relocations.c`:

```c
esp_err_t apply_xtensa_slot0_relocation(void *location, uintptr_t value);
// Add other Xtensa-specific relocation handlers
```

Reference: Xtensa ISA documentation for instruction encoding.

### Step 4: Integration

Update `components/reloadable/reloadable_util.c` to use the new loader:

```c
static elf_loader_ctx_t s_elf_ctx;

esp_err_t hotreload_init(void) {
    // Read ELF from flash partition
    const void *elf_data = map_hotreload_partition();

    // Load ELF
    ESP_ERROR_CHECK(elf_loader_init(&s_elf_ctx, elf_data));
    ESP_ERROR_CHECK(elf_loader_allocate(&s_elf_ctx));
    ESP_ERROR_CHECK(elf_loader_load_sections(&s_elf_ctx));
    ESP_ERROR_CHECK(elf_loader_apply_relocations(&s_elf_ctx));
    ESP_ERROR_CHECK(elf_loader_sync_cache(&s_elf_ctx));

    // Populate symbol table
    hotreload_symbol_table[0] = elf_loader_get_symbol(&s_elf_ctx, "reloadable_init");
    hotreload_symbol_table[1] = elf_loader_get_symbol(&s_elf_ctx, "reloadable_hello");

    return ESP_OK;
}
```

## Testing Strategy

### Unit Tests

1. **Section Loading:** Verify sections copied correctly to RAM
2. **Relocation Calculation:** Test relocation formulas with known values
3. **Symbol Resolution:** Check symbols resolve to correct addresses

### Integration Tests

1. Load simple ELF, call exported function, verify output
2. Load complex ELF (with static arrays, strings), verify data integrity
3. Reload ELF multiple times, check for memory leaks
4. Test with different optimization levels (-O0, -O2, -Os)

### Platform Tests

- Verify on ESP32 (Xtensa)
- Verify on ESP32-C3 (RISC-V) once RISC-V relocations are implemented

## Open Questions

1. **RISC-V Support:** Need to add RISC-V relocation types (R_RISCV_*) when targeting ESP32-C3/C6/etc.

2. **Thread Safety:** Should loading be protected by mutex? Currently assuming single-threaded init.

3. **Error Recovery:** If relocation fails mid-way, should we:
   - Leave partially relocated code (dangerous)
   - Keep old version valid (requires double buffering)
   - Mark as invalid and refuse to call (safest, simplest)

4. **Unload/Reload:** For runtime reload, need to:
   - Wait for no active calls into reloadable code
   - Free old RAM allocation
   - Load new version
   - Update symbol table atomically

## References

- ESP-IDF ELF Loader (esp-iot-solution): General loading approach
- Xtensa ISA Reference Manual: Instruction encoding for SLOT0_OP relocations
- Generic ELF specification: ELF structure, relocation types
- Current elf_parser implementation: Iterator patterns, section parsing
